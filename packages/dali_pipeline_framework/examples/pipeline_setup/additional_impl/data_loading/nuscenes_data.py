# Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Tuple, Sequence, List, Union
import copy
import pickle
import numpy as np

import nuscenes


class NuScenesDataSample:
    '''Represents a single sample.

    Sample means as defined in the NuScenes dataset. Depending on the use-case, this does not necessarily
    correspond to a training sample.

    The contained properties correspond to the parameters of the constructor. Please refer to the constructor
    documentation for more information.

    Note that most the individual entries are stored in the format as provided by the NuScenes DevKit.
    This means that for these entries, while the data is re-structured for easy access, no conversion of
    the actual data happens. Some entries are processed in order to avoid needing the dataset in the
    original format once it is converted to this internal format.
    '''

    def __init__(
        self,
        sample: dict,
        camera_samples: List[dict],
        camera_calibration: List[dict],
        ego_poses_at_cam_timestamps: List[dict],
        annotations: List[dict],
        objects_in_lidar_coords: List[nuscenes.utils.data_classes.Box],
        annotation_velocities: List[np.ndarray],
        visibilities: List[dict],
        image_annotations: Union[List[dict], None],
        projected_bboxes_annotations: Union[List[dict], None],
        lidar_calibration_data: dict,
        ego_pose_at_lidar_timestamp: dict,
        can_messages: Union[List[dict], None] = None,
    ):
        '''

        Args:
            sample: The sample(as 'sample' defined by NuScenes, i.e. containing all information
                for a given point in time)
            camera_samples: The camera data in this sample. This is a list, where each entry corresponds to
                a camera.
            camera_calibration: The camera calibrations in this sample. This is a list, where each entry
                corresponds to a camera.
            ego_poses_at_cam_timestamps: Ego-poses for the vehicle corresponding to the exact points in time
                for which the camera data was obtained.
            annotations: Annotations (as defined in NuScenes, i.e. annotations of objects present in the
                sample). This is a list, where each entry corresponds to an object in the sample.
            objects_in_lidar_coords: Annotation objects in lidar coordinates. This is a list,
                where each entry corresponds to an object in the sample.
            annotation_velocities: Velocities for the individual objects/bounding boxes in the annotations.
                This is a list, where each entry corresponds to an object in the sample.
            visibilities: Visibilities for the individual objects (as defined in NuScenes). This is a list,
                where each entry corresponds to an object in the sample.
            image_annotations: Image annotations for the individual cameras, i.e. description of the objects
                projected into the camera image (as generated by
                nuscenes.scripts.export_2d_annotations_as_json; see prepare_dataset.py). This is a list,
                where each entry corresponds to a camera.
                Can be set to ``None`` if not needed.
            projected_bboxes_annotations: Projected bounding boxes annotations for the individual cameras,
                i.e. description of the objects projected into the camera image. Note that this is
                similar to ``image_annotations``. However, the :class:`BboxProjector` is used to project
                the 3D bounding boxes to 2D. This leads to a different annotation format (e.g. including
                the depths of the bounding box centers).
                This is a list, where each entry corresponds to a camera.
                Can be set to ``None`` if not needed.
            lidar_calibration_data: The lidar calibration in this sample.
            ego_pose_at_lidar_timestamp: The ego-pose for the vehicle corresponding to the exact point
                in time for which the lidar data was obtained.
            can_messages: CAN messages for the individual samples.
        '''
        self.sample = sample
        self.camera_samples = camera_samples
        self.camera_calibration = camera_calibration
        self.ego_poses_at_cam_timestamps = ego_poses_at_cam_timestamps
        self.annotations = annotations
        self.objects_in_lidar_coords = objects_in_lidar_coords
        self.annotation_velocities = annotation_velocities
        self.visibilities = visibilities
        self.image_annotations = image_annotations
        self.projected_bboxes_annotations = projected_bboxes_annotations
        self.lidar_calibtation_data = lidar_calibration_data
        self.ego_pose_at_lidar_timestamp = ego_pose_at_lidar_timestamp
        self.can_messages = can_messages


class NuScenesDataSequence:
    '''Represents a sequence of samples.

    A sequence is a list of samples, which were obtained in sequence during one recording.
    IN the NuScenes dataset, the individual scenes are such sequences. However, note that
    a scene can also be sub-divided into shorter sequences.
    '''

    def __init__(
        self,
        name: str,
        samples: List[dict],
        camera_samples: List[List[dict]],
        camera_calibration: List[List[dict]],
        ego_poses_at_cam_timestamps: List[List[dict]],
        annotations: List[List[dict]],
        objects_in_lidar_coords: List[List[nuscenes.utils.data_classes.Box]],
        annotation_vels: List[List[np.ndarray]],
        visibilities: List[List[dict]],
        image_annotations: Union[List[Union[List[dict], None]], None],
        projected_bboxes_annotations: Union[List[Union[List[dict], None]], None],
        lidar_calibration_data: List[dict],
        ego_pose_at_lidar_timestamps: List[dict],
        can_messages: Union[List[Union[List[dict], None]], None] = None,
    ):
        '''

        Note:
            Sequence refers to a sequence of samples. In the NuScenes dataset, the
            individual scenes are such sequences. Note that the scene can also be sub-divided
            into shorter sequences.

        Args:
            name: Name of the sequence (e.g. scene name)
            samples: List of samples in the sequence (in the original format)
            camera_samples: List of camera samples in the sequence
                The inner list iterates over the cameras in each sample.
            camera_calibration: List of camera calibrations in the sequence
                The inner list iterates over the cameras in each sample.
            ego_poses_at_cam_timestamps: List of ego-poses at camera timestamps in the sequence
                The inner list iterates over the cameras in each sample.
            annotations: List of annotations in the sequence
                The inner list iterates over the objects in each sample.
            objects_in_lidar_coords: List of objects in lidar coordinates in the sequence
                The inner list iterates over the objects in each sample.
            annotation_vels: List of annotation velocities in the sequence
                The inner list iterates over the objects in each sample.
            visibilities: List of visibilities in the sequence
                The inner list iterates over the objects in each sample.
            image_annotations: List of image annotations in the sequence
                The inner list iterates over the cameras in each sample.
                Can be set to ``None`` if not needed.
            projected_bboxes_annotations: List of projected bounding boxes annotations in the sequence.
                Note that this is similar to `image_annotations`. However, the :class:`BboxProjector` is
                used to project the 3D bounding boxes to 2D. This leads to a different annotation format
                (e.g. including the depths of the bounding box centers).
                The inner list iterates over the cameras in each sample.
                Can be set to ``None`` if not needed.
            lidar_calibration_data: List of lidar calibration data in the sequence
            ego_pose_at_lidar_timestamps: List of ego-poses at lidar timestamps in the sequence
            can_messages: List of CAN messages in the sequence
                The inner list iterates over the CAN messages in each sample.
                Can be set to `None` if not needed.
        '''
        if can_messages is None:
            can_messages = [None] * len(samples)
        if image_annotations is None:
            image_annotations = [None] * len(samples)
        if projected_bboxes_annotations is None:
            projected_bboxes_annotations = [None] * len(samples)
        self._samples = [
            NuScenesDataSample(s, cs, cc, epc, an, obj_lidar, anv, vs, ia, pba, lc, epl, cm)
            for s, cs, cc, epc, an, obj_lidar, anv, vs, ia, pba, lc, epl, cm in zip(
                samples,
                camera_samples,
                camera_calibration,
                ego_poses_at_cam_timestamps,
                annotations,
                objects_in_lidar_coords,
                annotation_vels,
                visibilities,
                image_annotations,
                projected_bboxes_annotations,
                lidar_calibration_data,
                ego_pose_at_lidar_timestamps,
                can_messages,
            )
        ]
        self._name = name

    def __len__(self) -> int:
        '''Get the length of the sequence.'''
        return len(self._samples)

    def __getitem__(self, index: int) -> NuScenesDataSample:
        '''Get a sample from the sequence.

        Args:
            index: Index of the sample.

        Returns:
            The sample.
        '''
        return self._samples[index]

    def get_sub_sequence(self, first: int, last_ext: int) -> 'NuScenesDataSequence':
        '''Get a sub-sequence of the current sequence.

        Important:
            This can e.g. be used to obtain a larger number of shorter sequences for the training.

            DO NOT use the so obtained sequences in different sets (e.g. training, validation, test),
            as the so obtained sequences are highly correlated.

        Args:
            first: First index of the sub-sequence (inclusive).
            last_ext: Last index of the sub-sequence (exclusive).

        Returns:
            The sub-sequence.
        '''

        samples = self._samples

        # Copy `self`, but without copying the samples
        self._samples = None
        res = copy.deepcopy(self)
        self._samples = samples

        res._samples = samples[first:last_ext]
        res._name = res._name + f"[{first}:{last_ext}]"

        return res

    @property
    def name(self) -> str:
        '''Get the name of the sequence.'''
        return self._name


class NuScenesData:
    '''Represents a complete dataset in the NuScenes format.

    The dataset is a collection of sequences.
    '''

    def __init__(self, sequences: Sequence[NuScenesDataSequence], cams: Sequence[str], base_dir: str):
        '''

        Args:
            sequences: List of sequences in the dataset.
            cams: List of camera names in the dataset.
                Note that inside the sequences, the cameras are identified by their index.
                The ``cams`` parameter is used to assign a name to each index.
            base_dir: Base directory of the dataset.
        '''
        self._sequences = sequences
        self._total_num_samples = None

        flattened_idx_mapping = []
        total_num_samples = 0
        for i_seq, seq in zip(range(len(sequences)), sequences):
            num_samples = len(seq)
            mappings_seq = [(i_seq, i) for i in range(num_samples)]
            flattened_idx_mapping += mappings_seq
            total_num_samples += num_samples

        self._total_num_samples = total_num_samples
        self._flattened_idx_mapping = flattened_idx_mapping
        self._cams = cams
        self._base_dir = base_dir
        self._sequences_are_split = False

    @property
    def total_num_samples(self) -> int:
        '''Get the total number of samples in the dataset.'''
        return self._total_num_samples

    @property
    def num_sample_in_sequence(self, sequence_idx: int) -> int:
        '''Get the number of samples in a sequence.

        Args:
            sequence_idx: Index of the sequence.

        Returns:
            The number of samples in the sequence.
        '''
        return len(self._sequences[sequence_idx])

    @property
    def num_sequences(self) -> int:
        '''Get the number of sequences in the dataset.'''
        return len(self._sequences)

    @property
    def cams(self) -> List[str]:
        '''Get the names of the cameras in the dataset.

        Note:
            In the data, the cameras are arranged in the order of
            the names as returned here (defined on construction).
        '''
        return self._cams

    @property
    def base_dir(self) -> str:
        '''Get the base directory of the dataset.'''
        return self._base_dir

    def get_sample_in_sequence(self, sequence_idx: int, sample_idx: int) -> NuScenesDataSample:
        '''Get a sample from a sequence.

        Args:
            sequence_idx: Index of the sequence.
            sample_idx: Index of the sample.

        Returns:
            The sample.
        '''
        return self._sequences[sequence_idx][sample_idx]

    def get_sequence(self, sequence_idx: int) -> NuScenesDataSequence:
        '''Get a sequence from the dataset.

        Args:
            sequence_idx: Index of the sequence.

        Returns:
            The sequence.
        '''
        return self._sequences[sequence_idx]

    def get_sequence_and_sample_idx_from_flattened_idx(self, flattened_sample_idx: int) -> Tuple[int, int]:
        '''Get the sequence and sample index from a flattened index.

        Note:
            The flattened index is the index of the sample in the dataset. It assumes
            that the sequences are concatenated in the order in which they were added
            to the dataset (or obtained by calling one of the methods
            returning a ``NuScenesData`` object).

        Args:
            flattened_sample_idx: Flattened index of the sample.

        Returns:
            The sequence and sample index.
        '''
        return self._flattened_idx_mapping[flattened_sample_idx]

    def get_sample_from_flattened_idx(self, flattened_sample_idx: int) -> NuScenesDataSample:
        '''Get a sample from a flattened index.

        Also see :meth:`get_sequence_and_sample_idx_from_flattened_idx` for information
        on how the flattened index is defined.

        Args:
            flattened_sample_idx: Flattened index of the sample.

        Returns:
            The sample.
        '''
        sequence_idx, sample_idx = self.get_sequence_and_sample_idx_from_flattened_idx(flattened_sample_idx)
        return self._sequences[sequence_idx][sample_idx]

    def get_subset_sequences_in_sequence_order(self, sequence_names: List[str]) -> 'NuScenesData':
        '''Get a subset of the sequences in the order of the sequences.

        Args:
            sequence_names: List of names of the sequences to include. The order of the
                sequences in the list determines the order of the sequences in the returned
                :class:`NuScenesData` object.

        Returns:
            The subset of the sequences.
        '''
        if self._sequences_are_split:
            raise RuntimeError(
                "Cannot call `get_subset_sequences_in_sequence_order()` for `NuScenesData` objects whole sequences have been split (i.e. which is obtained by calling `get_with_sequences_split()`)"
            )
        res_sequences = []
        for sqn in sequence_names:
            sequence_found = False
            for seq in self._sequences:
                if seq.name == sqn:
                    res_sequences.append(seq)
                    sequence_found = True
                    break
            if not sequence_found:
                raise KeyError(f"Sequence with name '{sqn}' not found.")

        res = NuScenesData(res_sequences, self._cams, self._base_dir)
        return res

    def get_subset_without_sequences(self, sequence_names: List[str]) -> 'NuScenesData':
        '''Get a subset of the sequences without the specified sequences.

        Args:
            sequence_names: List of names of the sequences to remove.

        Returns:
            New dataset without the specified sequences. The order of the sequences in the
            returned ``NuScenesData`` object is the same as the order of the sequences in the
            original dataset (with the specified sequences removed).
        '''
        if self._sequences_are_split:
            raise RuntimeError(
                "Cannot call `get_subset_without_sequences()` for `NuScenesData` objects whole sequences have been split (i.e. which is obtained by calling `get_with_sequences_split()`)"
            )
        set_to_remove = set(sequence_names)
        if len(set_to_remove) != len(sequence_names):
            raise KeyError("Duplicate(s) present in `sequence_names`.")

        removed_sequences_set = set()
        res_sequences = []
        for seq in self._sequences:
            if not (seq.name in set_to_remove):
                res_sequences.append(seq)
            else:
                removed_sequences_set.add(seq)

        if len(removed_sequences_set) < len(set_to_remove):
            missing_sequences = set_to_remove - removed_sequences_set
            raise KeyError(
                f"Did not find all the sequences to remove. Not found sequences are: {missing_sequences}"
            )

        res = NuScenesData(res_sequences, self._cams, self._base_dir)
        return res

    def get_sequences_sorted_by_start_time(self) -> 'NuScenesData':
        '''Get the sequences sorted by start time.

        Note:
            The start time is defined as the timestamp of the first sample in the sequence.

        Returns:
            The sequences sorted by start time.
        '''
        start_times = [seq[0].sample["timestamp"] for seq in self._sequences]
        start_times = np.array(start_times)
        seq_order = np.argsort(start_times)
        seq_sorted = [self._sequences[i] for i in seq_order]
        res = NuScenesData(seq_sorted, self._cams, self._base_dir)
        return res

    def get_sequence_lengths(self) -> List[int]:
        '''Get the lengths of the sequences.

        Returns:
            The lengths of the sequences.
        '''
        res = [len(seq) for seq in self._sequences]
        return res

    def get_with_sequences_split(
        self, split_into_num_parts: int, favor_longer_first: bool = True
    ) -> 'NuScenesData':
        '''Get a new dataset with the sequences split into the specified number of parts.

        Args:
            split_into_num_parts: Number of parts to split the sequences into.
            favor_longer_first: If the number of elements in the sequence is not divisible by the number of
                parts, some of the parts will be one element longer than the others. If ``favor_longer_first``
                is ``True``, the longer parts are the first ones (i.e. at the beginning of the original
                sequence). If ``favor_longer_first`` is ``False``, the longer parts are the last ones.

        Returns:
            The new dataset with the sequences split into the specified number of parts.
        '''

        res_seqs = []
        for seq in self._sequences:
            seq_len = len(seq)
            new_len_smaller = seq_len // split_into_num_parts
            remaining = seq_len - new_len_smaller * split_into_num_parts
            new_len_larger = new_len_smaller + 1
            new_lens = [
                new_len_larger if i < remaining else new_len_smaller for i in range(split_into_num_parts)
            ]
            if not favor_longer_first:
                new_lens = list(reversed(new_lens))
            num_elements_used = 0
            for nl in new_lens:
                sub_seq = seq.get_sub_sequence(num_elements_used, nl + num_elements_used)
                res_seqs.append(sub_seq)
                num_elements_used += nl

        res = NuScenesData(res_seqs, self._cams, self._base_dir)
        res._sequences_are_split = True
        return res

    def store_pickled(self, filename):
        with open(filename, 'wb') as file:
            pickle.dump(self, file)

    @staticmethod
    def load_pickled(filename):
        with open(filename, 'rb') as file:
            obj = pickle.load(file)
        if not isinstance(obj, NuScenesData):
            raise RuntimeError(f"Content of file '{file}' is not a `NuScenesData` instance.")
        return obj
